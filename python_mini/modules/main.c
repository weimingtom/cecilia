//20180406
#include "python.h"
#include "osdefs.h"
#include "compile.h"

#include <fcntl.h>

#define PYTHONHOMEHELP "<prefix>\\lib"

#include "pygetopt.h"

#define COPYRIGHT \
    "Type \"help\", \"copyright\", \"credits\" or \"license\" " \
    "for more information."

static char **orig_argv;
static int  orig_argc;

#define BASE_OPTS "c:dEhiOQ:StuUvVW:xX"

#define PROGRAM_OPTS BASE_OPTS

static char *usage_line =
	"usage: %s [option] ... [-c cmd | file | -] [arg] ...\n";

static char *usage_1 = ""
	"Options and arguments (and corresponding environment variables):\n"
	"-c cmd : program passed in as string (terminates option list)\n"
	"-d     : debug output from parser (also PYTHONDEBUG=x)\n"
	"-E     : ignore environment variables (such as PYTHONPATH)\n"
	"-h     : print this help message and exit\n"
	"-i     : inspect interactively after running script, (also PYTHONINSPECT=x)\n"
	"         and force prompts, even if stdin does not appear to be a terminal\n"
	"";

static char *usage_2 = ""
	"-O     : optimize generated bytecode (a tad; also PYTHONOPTIMIZE=x)\n"
	"-OO    : remove doc-strings in addition to the -O optimizations\n"
	"-Q arg : division options: -Qold (default), -Qwarn, -Qwarnall, -Qnew\n"
	"-S     : don't imply 'import site' on initialization\n"
	"-t     : issue warnings about inconsistent tab usage (-tt: issue errors)\n"
	"-u     : unbuffered binary stdout and stderr (also PYTHONUNBUFFERED=x)\n"
	"";

static char *usage_3 = ""
	"-v     : verbose (trace import statements) (also PYTHONVERBOSE=x)\n"
	"-V     : print the Python version number and exit\n"
	"-W arg : warning control (arg is action:message:category:module:lineno)\n"
	"-x     : skip first line of source, allowing use of non-Unix forms of #!cmd\n"
	"file   : program read from script file\n"
	"-      : program read from stdin (default; interactive mode if a tty)\n"
	"";

static char *usage_4 = ""
	"arg ...: arguments passed to program in sys.argv[1:]\n"
	"Other environment variables:\n"
	"PYTHONSTARTUP: file executed on interactive startup (no default)\n"
	"PYTHONPATH   : '%c'-separated list of directories prefixed to the\n"
	"               default module search path.  The result is sys.path.\n"
	"PYTHONHOME   : alternate <prefix> directory (or <prefix>%c<exec_prefix>).\n"
	"               The default module search path uses %s.\n"
	"PYTHONCASEOK : ignore case in 'import' statements (Windows).\n"
	"";

static void usage(int exitcode, char* program)
{
	FILE *f = exitcode ? stderr : stdout;

	fprintf(f, usage_line, program);
	if (exitcode)
	{
		fprintf(f, "Try `python -h' for more information.\n");
	}
	else 
	{
		fprintf(f, "%s", usage_1);
		fprintf(f, "%s", usage_2);
		fprintf(f, "%s", usage_3);
		fprintf(f, usage_4, DELIM, DELIM, PYTHONHOMEHELP);
	}
	exit(exitcode);
}

DL_EXPORT(int) Py_Main(int argc, char **argv)
{
	int c;
	int sts;
	char *command = NULL;
	char *filename = NULL;
	FILE *fp = stdin;
	char *p;
	int inspect = 0;
	int unbuffered = 0;
	int skipfirstline = 0;
	int stdin_is_interactive = 0;
	int help = 0;
	int version = 0;
	int saw_inspect_flag = 0;
	int saw_unbuffered_flag = 0;
	PyCompilerFlags cf;

	cf.cf_flags = 0;

	orig_argc = argc;
	orig_argv = argv;

	PySys_ResetWarnOptions();

	while ((c = _PyOS_GetOpt(argc, argv, PROGRAM_OPTS)) != EOF) 
	{
		if (c == 'c') 
		{
			command = malloc(strlen(_PyOS_optarg) + 2);
			if (command == NULL)
			{
				Py_FatalError(
				   "not enough memory to copy -c argument");
			}
			strcpy(command, _PyOS_optarg);
			strcat(command, "\n");
			break;
		}

		switch (c) 
		{
		case 'd':
			Py_DebugFlag++;
			break;

		case 'Q':
			if (strcmp(_PyOS_optarg, "old") == 0) 
			{
				Py_DivisionWarningFlag = 0;
				break;
			}
			if (strcmp(_PyOS_optarg, "warn") == 0) 
			{
				Py_DivisionWarningFlag = 1;
				break;
			}
			if (strcmp(_PyOS_optarg, "warnall") == 0) 
			{
				Py_DivisionWarningFlag = 2;
				break;
			}
			if (strcmp(_PyOS_optarg, "new") == 0) 
			{
				cf.cf_flags |= CO_FUTURE_DIVISION;
				_Py_QnewFlag = 1;
				break;
			}
			fprintf(stderr,
				"-Q option should be `-Qold', "
				"`-Qwarn', `-Qwarnall', or `-Qnew' only\n");
			usage(2, argv[0]);
			//no break;

		case 'i':
			inspect++;
			saw_inspect_flag = 1;
			Py_InteractiveFlag++;
			break;

		case 'O':
			Py_OptimizeFlag++;
			break;

		case 'S':
			Py_NoSiteFlag++;
			break;

		case 'E':
			Py_IgnoreEnvironmentFlag++;
			break;

		case 't':
			Py_TabcheckFlag++;
			break;

		case 'u':
			unbuffered++;
			saw_unbuffered_flag = 1;
			break;

		case 'v':
			Py_VerboseFlag++;
			break;

		case 'x':
			skipfirstline = 1;
			break;

		case 'U':
			Py_UnicodeFlag++;
			break;
		case 'h':
			help++;
			break;
		case 'V':
			version++;
			break;

		case 'W':
			PySys_AddWarnOption(_PyOS_optarg);
			break;

		default:
			usage(2, argv[0]);
			//no break;
		}
	}

	if (help)
	{
		usage(0, argv[0]);
	}

	if (version) 
	{
		fprintf(stderr, "Python %s\n", PY_VERSION);
		exit(0);
	}

	if (!saw_inspect_flag &&
	    (p = Py_GETENV("PYTHONINSPECT")) && *p != '\0')
	{
		inspect = 1;
	}
	if (!saw_unbuffered_flag &&
	    (p = Py_GETENV("PYTHONUNBUFFERED")) && *p != '\0')
	{
		unbuffered = 1;
	}

	if (command == NULL && _PyOS_optind < argc &&
	    strcmp(argv[_PyOS_optind], "-") != 0)
	{
		filename = argv[_PyOS_optind];
		if (filename != NULL) 
		{
			if ((fp = fopen(filename, "r")) == NULL) 
			{
				fprintf(stderr, "%s: can't open file '%s'\n",
					argv[0], filename);
				exit(2);
			}
			else if (skipfirstline) 
			{
				int ch;
				while ((ch = getc(fp)) != EOF) 
				{
					if (ch == '\n') 
					{
						ungetc(ch, fp);
						break;
					}
				}
			}
		}
	}

	stdin_is_interactive = Py_FdIsInteractive(stdin, (char *)0);

	if (unbuffered) 
	{
		_setmode(fileno(stdin), O_BINARY);
		_setmode(fileno(stdout), O_BINARY);
		setvbuf(stdin,  (char *)NULL, _IONBF, BUFSIZ);
		setvbuf(stdout, (char *)NULL, _IONBF, BUFSIZ);
		setvbuf(stderr, (char *)NULL, _IONBF, BUFSIZ);
	}
	else if (Py_InteractiveFlag) 
	{
		setvbuf(stdout, (char *)NULL, _IONBF, BUFSIZ);
	}

	Py_SetProgramName(argv[0]);
	Py_Initialize();

	if (Py_VerboseFlag ||
	    (command == NULL && filename == NULL && stdin_is_interactive))
	{
		fprintf(stderr, "Python %s on %s\n%s\n",
			Py_GetVersion(), Py_GetPlatform(), COPYRIGHT);
	}

	if (command != NULL) 
	{
		_PyOS_optind--;
		argv[_PyOS_optind] = "-c";
	}

	PySys_SetArgv(argc-_PyOS_optind, argv+_PyOS_optind);

	if ((inspect || (command == NULL && filename == NULL)) &&
	    isatty(fileno(stdin))) 
	{
		PyObject *v;
		v = PyImport_ImportModule("readline");
		if (v == NULL)
		{
			PyErr_Clear();
		}
		else
		{
			Py_DECREF(v);
		}
	}

	if (command) 
	{
		sts = PyRun_SimpleStringFlags(command, &cf) != 0;
		free(command);
	}
	else 
	{
		if (filename == NULL && stdin_is_interactive) 
		{
			char *startup = Py_GETENV("PYTHONSTARTUP");
			if (startup != NULL && startup[0] != '\0') 
			{
				FILE *fp = fopen(startup, "r");
				if (fp != NULL) 
				{
					PyRun_SimpleFile(fp, startup);
					PyErr_Clear();
					fclose(fp);
				}
			}
		}
		sts = PyRun_AnyFileExFlags(
			fp,
			filename == NULL ? "<stdin>" : filename,
			filename != NULL, &cf) != 0;
	}

	if (inspect && stdin_is_interactive &&
	    (filename != NULL || command != NULL))
	{
		sts = PyRun_AnyFileFlags(stdin, "<stdin>", &cf) != 0;
	}

	Py_Finalize();

	return sts;
}

void Py_GetArgcArgv(int *argc, char ***argv)
{
	*argc = orig_argc;
	*argv = orig_argv;
}
